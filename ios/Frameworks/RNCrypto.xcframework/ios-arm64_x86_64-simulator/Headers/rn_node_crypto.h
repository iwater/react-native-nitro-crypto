// React Native Node Crypto - C API
// Auto-generated by build.rs
#ifndef RN_NODE_CRYPTO_H
#define RN_NODE_CRYPTO_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stddef.h>

// ==================== Random ====================

/**
 * Fills the buffer with cryptographically strong random bytes.
 * Corresponds to: crypto.randomBytes(size)
 * @param buf Pointer to the buffer to fill
 * @param len Number of bytes to generate
 */
void rn_crypto_random_bytes(uint8_t* buf, size_t len);

// ==================== Hash ====================

/**
 * Computes the SHA-1 hash of the input data.
 * Corresponds to: crypto.createHash('sha1').update(data).digest()
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 20 bytes
 */
void rn_crypto_sha1(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA-256 hash of the input data.
 * Corresponds to: crypto.createHash('sha256').update(data).digest()
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 32 bytes
 */
void rn_crypto_sha256(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA-512 hash of the input data.
 * Corresponds to: crypto.createHash('sha512').update(data).digest()
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 64 bytes
 */
void rn_crypto_sha512(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the MD5 hash of the input data.
 * Corresponds to: crypto.createHash('md5').update(data).digest()
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 16 bytes
 */
void rn_crypto_md5(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA-384 hash of the input data.
 * Corresponds to: crypto.createHash('sha384').update(data).digest()
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 48 bytes
 */
void rn_crypto_sha384(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA3-256 hash of the input data.
 * Corresponds to: subtle.digest('SHA3-256', data)
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 32 bytes
 */
void rn_crypto_sha3_256(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA3-384 hash of the input data.
 * Corresponds to: subtle.digest('SHA3-384', data)
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 48 bytes
 */
void rn_crypto_sha3_384(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes the SHA3-512 hash of the input data.
 * Corresponds to: subtle.digest('SHA3-512', data)
 * @param data Pointer to input data
 * @param len Length of input data
 * @param out_hash Pointer to a buffer of at least 64 bytes
 */
void rn_crypto_sha3_512(const uint8_t* data, size_t len, uint8_t* out_hash);

/**
 * Computes cSHAKE128 with variable output length.
 * Corresponds to: subtle.digest({ name: 'cSHAKE128', ... }, data)
 * @param data Pointer to input data
 * @param data_len Length of input data
 * @param customization Pointer to customization string (can be NULL)
 * @param customization_len Length of customization string
 * @param out_hash Pointer to output buffer
 * @param out_len Desired output length
 */
void rn_crypto_cshake128(const uint8_t* data, size_t data_len,
                         const uint8_t* customization, size_t customization_len,
                         uint8_t* out_hash, size_t out_len);

/**
 * Computes cSHAKE256 with variable output length.
 * Corresponds to: subtle.digest({ name: 'cSHAKE256', ... }, data)
 * @param data Pointer to input data
 * @param data_len Length of input data
 * @param customization Pointer to customization string (can be NULL)
 * @param customization_len Length of customization string
 * @param out_hash Pointer to output buffer
 * @param out_len Desired output length
 */
void rn_crypto_cshake256(const uint8_t* data, size_t data_len,
                         const uint8_t* customization, size_t customization_len,
                         uint8_t* out_hash, size_t out_len);

// ==================== HMAC ====================

/**
 * Computes HMAC-SHA256.
 * Corresponds to: crypto.createHmac('sha256', key).update(data).digest()
 * @param key Pointer to the secret key
 * @param key_len Length of the key
 * @param data Pointer to input data
 * @param data_len Length of input data
 * @param out_hash Pointer to a buffer of at least 32 bytes
 */
void rn_crypto_hmac_sha256(const uint8_t* key, size_t key_len,
                           const uint8_t* data, size_t data_len,
                           uint8_t* out_hash);

// ==================== Generic HMAC Context API ====================

typedef struct HmacContext HmacContext;

/**
 * Creates a new HMAC context.
 * Corresponds to: crypto.createHmac(algorithm, key)
 * Supported algorithms: sha1, sha256, sha384, sha512, md5, sha3-256, sha3-384, sha3-512
 * @param algo Algorithm name
 * @param algo_len Length of algorithm name
 * @param key Secret key
 * @param key_len Length of key
 * @return Pointer to HmacContext, or NULL if unsupported algorithm
 */
HmacContext* rn_crypto_hmac_create(const uint8_t* algo, size_t algo_len,
                                    const uint8_t* key, size_t key_len);

/**
 * Updates HMAC with data.
 * Corresponds to: hmac.update(data)
 * @param ctx HMAC context
 * @param data Input data
 * @param data_len Length of data
 */
void rn_crypto_hmac_update(HmacContext* ctx, const uint8_t* data, size_t data_len);

/**
 * Finalizes HMAC and returns digest.
 * Corresponds to: hmac.digest()
 * @param ctx HMAC context (consumed after this call)
 * @param out Output buffer (must be large enough for algorithm's output)
 * @return Length of digest written, or 0 on error
 */
size_t rn_crypto_hmac_digest(HmacContext* ctx, uint8_t* out);

/**
 * Frees HMAC context without getting digest.
 * @param ctx HMAC context to free
 */
void rn_crypto_hmac_free(HmacContext* ctx);

/**
 * Gets output length for an HMAC algorithm.
 * @param algo Algorithm name
 * @param algo_len Length of algorithm name
 * @return Output length in bytes, or 0 if unsupported
 */
size_t rn_crypto_hmac_output_len(const uint8_t* algo, size_t algo_len);

// ==================== PBKDF2 ====================

/**
 * Derives a key using PBKDF2-HMAC-SHA256.
 * Corresponds to: crypto.pbkdf2Sync(password, salt, iterations, keylen, 'sha256')
 * @param password Pointer to password
 * @param password_len Length of password
 * @param salt Pointer to salt
 * @param salt_len Length of salt
 * @param iterations Number of iterations
 * @param out_key Pointer to output buffer
 * @param key_len Desired key length
 */
void rn_crypto_pbkdf2_sha256(const uint8_t* password, size_t password_len,
                              const uint8_t* salt, size_t salt_len,
                              uint32_t iterations,
                              uint8_t* out_key, size_t key_len);

// ==================== Diffie-Hellman ====================

typedef struct DiffieHellman DiffieHellman;

/**
 * Creates a new Diffie-Hellman instance.
 * @param prime Prime number (p)
 * @param prime_len Length of prime
 * @param generator Generator (g)
 * @param generator_len Length of generator
 * @return Pointer to DiffieHellman instance
 */
DiffieHellman* rn_crypto_dh_new(const uint8_t* prime, size_t prime_len,
                                const uint8_t* generator, size_t generator_len);

/**
 * Frees a Diffie-Hellman instance.
 * @param dh Pointer to DiffieHellman instance
 */
void rn_crypto_dh_free(DiffieHellman* dh);

/**
 * Generates private and public keys.
 * @param dh Pointer to DiffieHellman instance
 * @param out_pub Buffer to store public key (can be NULL to just get length)
 * @return Length of generated public key
 */
size_t rn_crypto_dh_generate_keys(DiffieHellman* dh, uint8_t* out_pub);

/**
 * Computes the shared secret.
 * @param dh Pointer to DiffieHellman instance
 * @param other_pub Other party's public key
 * @param other_len Length of other party's public key
 * @param out_secret Buffer to store shared secret (can be NULL to just get length)
 * @return Length of shared secret
 */
size_t rn_crypto_dh_compute_secret(DiffieHellman* dh,
                                   const uint8_t* other_pub, size_t other_len,
                                   uint8_t* out_secret);

/**
 * Getters and Setters
 * All getter functions return the length of the data.
 * If 'out' is NULL, they simply return the length relative to the internal data.
 */
size_t rn_crypto_dh_get_prime(DiffieHellman* dh, uint8_t* out);
size_t rn_crypto_dh_get_generator(DiffieHellman* dh, uint8_t* out);
size_t rn_crypto_dh_get_private_key(DiffieHellman* dh, uint8_t* out);
size_t rn_crypto_dh_get_public_key(DiffieHellman* dh, uint8_t* out);

void rn_crypto_dh_set_private_key(DiffieHellman* dh, const uint8_t* key, size_t key_len);
void rn_crypto_dh_set_public_key(DiffieHellman* dh, const uint8_t* key, size_t key_len);

// ==================== Prime Generation ====================

/**
 * Generate a random prime of specified bit length.
 * @param bits Bit length of the prime
 * @param out Buffer to store prime (can be NULL to just get length)
 * @return Length of generated prime in bytes
 */
size_t rn_crypto_generate_prime(size_t bits, uint8_t* out);

/**
 * Check if a candidate is prime (Miller-Rabin test).
 * @param candidate Candidate number as bytes (big-endian)
 * @param candidate_len Length of candidate
 * @return true if probably prime, false otherwise
 */
bool rn_crypto_check_prime(const uint8_t* candidate, size_t candidate_len);

/**
 * Creates a new DiffieHellman with generated prime of specified bit length.
 * @param prime_bits Bit length of prime
 * @param generator Generator value (typically 2 or 5)
 * @return Pointer to new DiffieHellman instance
 */
DiffieHellman* rn_crypto_dh_new_with_prime_length(size_t prime_bits, size_t generator);


// ==================== AES-KW ====================

/**
 * Wraps a key using AES Key Wrap (RFC 3394).
 * @param kek Pointer to Key Encryption Key
 * @param kek_len Length of KEK (16, 24, or 32 bytes)
 * @param key Pointer to key to wrap
 * @param key_len Length of key to wrap (must be multiple of 8)
 * @param out Output buffer (can be NULL to get size)
 * @return Size of wrapped key, or -1 on error
 */
int32_t rn_crypto_aes_kw_wrap(const uint8_t* kek, size_t kek_len,
                              const uint8_t* key, size_t key_len,
                              uint8_t* out);

/**
 * Unwraps a key using AES Key Wrap (RFC 3394).
 * @param kek Pointer to Key Encryption Key
 * @param kek_len Length of KEK
 * @param wrapped Pointer to wrapped key data
 * @param wrapped_len Length of wrapped key data
 * @param out Output buffer (can be NULL to get size)
 * @return Size of unwrapped key, or -1 on error
 */
int32_t rn_crypto_aes_kw_unwrap(const uint8_t* kek, size_t kek_len,
                                const uint8_t* wrapped, size_t wrapped_len,
                                uint8_t* out);

// ==================== Cipher / Decipher ====================

typedef struct CipherContext CipherContext;

/**
 * Creates a new Cipher/Decipher context.
 * @param algo Algorithm name (e.g. "aes-256-cbc")
 * @param algo_len Length of algo name
 * @param key Key buffer
 * @param key_len Length of key
 * @param iv IV buffer
 * @param iv_len Length of IV
 * @param is_decipher true for Decipher, false for Cipher
 * @return Pointer to Context or NULL
 */
CipherContext* rn_crypto_cipher_create(const uint8_t* algo, size_t algo_len,
                                       const uint8_t* key, size_t key_len,
                                       const uint8_t* iv, size_t iv_len,
                                       bool is_decipher);

/**
 * Updates the cipher with input data.
 * @param ctx Context
 * @param input Input data
 * @param input_len Length of input
 * @param out Output buffer (can be NULL to get size)
 * @return Bytes written
 */
size_t rn_crypto_cipher_update(CipherContext* ctx,
                               const uint8_t* input, size_t input_len,
                               uint8_t* out);

/**
 * Finalizes the cipher (handles padding).
 * @param ctx Context
 * @param out Output buffer (can be NULL to get size)
 * @return Bytes written
 */
size_t rn_crypto_cipher_final(CipherContext* ctx, uint8_t* out);

/**
 * Sets auto padding (for CBC mode).
 * @param ctx Context
 * @param auto_padding Enable/Disable padding
 */
void rn_crypto_cipher_set_auto_padding(CipherContext* ctx, bool auto_padding);

/**
 * Sets Additional Authenticated Data for AEAD modes (GCM).
 * @param ctx Cipher context
 * @param aad AAD buffer
 * @param aad_len Length of AAD
 */
void rn_crypto_cipher_set_aad(CipherContext* ctx, const uint8_t* aad, size_t aad_len);

/**
 * Gets the authentication tag after encryption (GCM mode).
 * @param ctx Cipher context
 * @param out Output buffer (can be NULL to get length)
 * @param out_cap Capacity of output buffer
 * @return Length of tag, or negative on error
 */
int32_t rn_crypto_cipher_get_auth_tag(CipherContext* ctx, uint8_t* out, size_t out_cap);

/**
 * Sets the authentication tag for decryption (GCM mode).
 * @param ctx Cipher context
 * @param tag Tag buffer
 * @param tag_len Length of tag
 */
void rn_crypto_cipher_set_auth_tag(CipherContext* ctx, const uint8_t* tag, size_t tag_len);

void rn_crypto_cipher_free(CipherContext* ctx);

// ==================== Certificate (SPKAC) ====================

size_t rn_crypto_cert_export_challenge(const uint8_t* spkac, size_t spkac_len, uint8_t* out);

size_t rn_crypto_cert_export_public_key(const uint8_t* spkac, size_t spkac_len, uint8_t* out);

bool rn_crypto_cert_verify_spkac(const uint8_t* spkac, size_t spkac_len);

// ==================== Sign / Verify ====================

typedef struct SignContext SignContext;
typedef struct VerifyContext VerifyContext;

SignContext* rn_crypto_sign_create(const uint8_t* algorithm, size_t algorithm_len);
void rn_crypto_sign_update(SignContext* ctx, const uint8_t* data, size_t data_len);
size_t rn_crypto_sign_sign(SignContext* ctx, const uint8_t* pem_key, size_t pem_len, uint8_t* out);
void rn_crypto_sign_free(SignContext* ctx);

VerifyContext* rn_crypto_verify_create(const uint8_t* algorithm, size_t algorithm_len);
void rn_crypto_verify_update(VerifyContext* ctx, const uint8_t* data, size_t data_len);
bool rn_crypto_verify_verify(VerifyContext* ctx, const uint8_t* pem_key, size_t pem_len, const uint8_t* signature, size_t sig_len);
void rn_crypto_verify_free(VerifyContext* ctx);

// ==================== X509Certificate ====================

typedef struct X509Context X509Context;

X509Context* rn_crypto_x509_parse(const uint8_t* data, size_t data_len);
size_t rn_crypto_x509_fingerprint(const X509Context* ctx, const uint8_t* algo, size_t algo_len, uint8_t* out);
size_t rn_crypto_x509_issuer(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_subject(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_serial(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_valid_from(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_valid_to(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_raw(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_to_pem(const X509Context* ctx, uint8_t* out);
// New X509 functions for verification and properties
bool rn_crypto_x509_is_ca(const X509Context* ctx);
size_t rn_crypto_x509_subject_alt_name(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_public_key(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_key_usage(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_ext_key_usage(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_info_access(const X509Context* ctx, uint8_t* out);
size_t rn_crypto_x509_check_email(const X509Context* ctx, const uint8_t* email, size_t email_len, bool check_subject, uint8_t* out);
size_t rn_crypto_x509_check_host(const X509Context* ctx, const uint8_t* host, size_t host_len, bool wildcards, uint8_t* out);
size_t rn_crypto_x509_check_ip(const X509Context* ctx, const uint8_t* ip, size_t ip_len, uint8_t* out);
bool rn_crypto_x509_verify(const X509Context* ctx, const uint8_t* pubkey, size_t pubkey_len);
bool rn_crypto_x509_check_issued(const X509Context* ctx, const X509Context* issuer_ctx);
bool rn_crypto_x509_check_private_key(const X509Context* ctx, const uint8_t* privkey, size_t privkey_len);
void rn_crypto_x509_free(X509Context* ctx);

// ==================== ECDH ====================

typedef struct ECDH ECDH;

ECDH* rn_crypto_ecdh_new(const uint8_t* curve, size_t curve_len);

// ==================== KeyObject ====================

typedef struct KeyObject KeyObject;

KeyObject* rn_crypto_key_object_new_secret(const uint8_t* data, size_t len);
KeyObject* rn_crypto_key_object_new_public(const uint8_t* data, size_t len);
KeyObject* rn_crypto_key_object_new_private(const uint8_t* data, size_t len);
void rn_crypto_key_object_free(KeyObject* key);
int32_t rn_crypto_key_object_get_type(KeyObject* key);
int32_t rn_crypto_key_object_get_asymmetric_key_type(KeyObject* key);
size_t rn_crypto_key_object_get_data(KeyObject* key, uint8_t* out);
int32_t rn_crypto_key_object_export(KeyObject* key, int32_t format, uint8_t* out);
KeyObject* rn_crypto_key_object_new_from_raw(const uint8_t* data, size_t len, int32_t alg_type, bool is_public);

// ==================== KeyGen ====================

int32_t rn_crypto_keygen_rsa(uint32_t modulus_bits, uint32_t public_exponent, KeyObject** out_pub, KeyObject** out_priv);
int32_t rn_crypto_keygen_ec(const char* curve_name, KeyObject** out_pub, KeyObject** out_priv);
int32_t rn_crypto_keygen_secret(size_t length, KeyObject** out_key);
int32_t rn_crypto_keygen_ed25519(KeyObject** out_pub, KeyObject** out_priv);
int32_t rn_crypto_keygen_x25519(KeyObject** out_pub, KeyObject** out_priv);
int32_t rn_crypto_keygen_ed448(KeyObject** out_pub, KeyObject** out_priv);
int32_t rn_crypto_keygen_x448(KeyObject** out_pub, KeyObject** out_priv);

// ==================== Asymmetric ====================

int32_t rn_crypto_public_encrypt(KeyObject* key, const uint8_t* data, size_t data_len, int32_t padding, uint8_t* out, size_t out_len);
int32_t rn_crypto_private_decrypt(KeyObject* key, const uint8_t* data, size_t data_len, int32_t padding, uint8_t* out, size_t out_len);
int32_t rn_crypto_private_encrypt(KeyObject* key, const uint8_t* data, size_t data_len, int32_t padding, uint8_t* out, size_t out_len);
int32_t rn_crypto_public_decrypt(KeyObject* key, const uint8_t* data, size_t data_len, int32_t padding, uint8_t* out, size_t out_len);

// ==================== Scrypt ====================

int32_t rn_crypto_scrypt(const uint8_t* password, size_t password_len, const uint8_t* salt, size_t salt_len, uint32_t n_val, uint32_t r_val, uint32_t p_val, size_t key_len, uint8_t* out);

// ==================== Argon2 ====================

int32_t rn_crypto_argon2(const uint8_t* password, size_t password_len, const uint8_t* salt, size_t salt_len, uint32_t iterations, uint32_t memory_cost, uint32_t parallelism, uint32_t hash_length, int32_t type_arg, int32_t version_arg, uint8_t* out);

// ==================== AEAD (AES-GCM, ChaCha20-Poly1305, AES-OCB) ====================

/**
 * AEAD encryption. Returns ciphertext || tag.
 * @param algo Algorithm name (e.g. "aes-256-gcm", "chacha20-poly1305", "aes-256-ocb")
 * @param algo_len Algorithm name length
 * @param key Encryption key
 * @param key_len Key length
 * @param nonce Nonce/IV
 * @param nonce_len Nonce length (usually 12)
 * @param plaintext Data to encrypt
 * @param plaintext_len Plaintext length
 * @param aad Additional authenticated data (can be NULL)
 * @param aad_len AAD length
 * @param out Output buffer (can be NULL to get size)
 * @param out_cap Output buffer capacity
 * @return Output length on success, negative on error
 */
int32_t rn_crypto_aead_encrypt(const uint8_t* algo, size_t algo_len,
                               const uint8_t* key, size_t key_len,
                               const uint8_t* nonce, size_t nonce_len,
                               const uint8_t* plaintext, size_t plaintext_len,
                               const uint8_t* aad, size_t aad_len,
                               uint8_t* out, size_t out_cap);

/**
 * AEAD decryption. Expects ciphertext || tag format.
 * @param algo Algorithm name
 * @param algo_len Algorithm name length
 * @param key Decryption key
 * @param key_len Key length
 * @param nonce Nonce/IV
 * @param nonce_len Nonce length
 * @param ciphertext Ciphertext with tag appended
 * @param ciphertext_len Ciphertext length (including tag)
 * @param aad Additional authenticated data (can be NULL)
 * @param aad_len AAD length
 * @param out Output buffer (can be NULL to get size)
 * @param out_cap Output buffer capacity
 * @return Output length on success, negative on error (authentication failure)
 */
int32_t rn_crypto_aead_decrypt(const uint8_t* algo, size_t algo_len,
                               const uint8_t* key, size_t key_len,
                               const uint8_t* nonce, size_t nonce_len,
                               const uint8_t* ciphertext, size_t ciphertext_len,
                               const uint8_t* aad, size_t aad_len,
                               uint8_t* out, size_t out_cap);

void rn_crypto_ecdh_free(ECDH* ecdh);
size_t rn_crypto_ecdh_generate_keys(ECDH* ecdh, uint8_t* out);
size_t rn_crypto_ecdh_compute_secret(const ECDH* ecdh, const uint8_t* other_pub, size_t other_len, uint8_t* out);
size_t rn_crypto_ecdh_get_private_key(const ECDH* ecdh, uint8_t* out);
size_t rn_crypto_ecdh_get_public_key(const ECDH* ecdh, bool compressed, uint8_t* out);
bool rn_crypto_ecdh_set_private_key(ECDH* ecdh, const uint8_t* key, size_t key_len);
bool rn_crypto_ecdh_set_public_key(ECDH* ecdh, const uint8_t* key, size_t key_len);

// ==================== DH KeyObject Shared Secret ====================

/**
 * Compute DH shared secret from KeyObject pointers.
 * Supports X25519, X448, EC (ECDH), and DH (FFDH) key types.
 * @param priv_key Private KeyObject
 * @param pub_key Public KeyObject
 * @param out Output buffer (can be NULL to get length)
 * @return Length of secret, or -1 on error
 */
int32_t rn_crypto_dh_compute_secret_from_keys(KeyObject* priv_key, KeyObject* pub_key, uint8_t* out);

// ==================== DH KeyObject Factory ====================

/**
 * Create a DH private key KeyObject with prime and generator.
 * @param prime DH prime (p)
 * @param prime_len Length of prime
 * @param generator DH generator (g)
 * @param gen_len Length of generator
 * @param private_value Private value (x)
 * @param priv_len Length of private value
 * @return KeyObject pointer or NULL on error
 */
KeyObject* rn_crypto_key_object_new_dh_private(
    const uint8_t* prime, size_t prime_len,
    const uint8_t* generator, size_t gen_len,
    const uint8_t* private_value, size_t priv_len);

/**
 * Create a DH public key KeyObject with prime and generator.
 * @param prime DH prime (p)
 * @param prime_len Length of prime
 * @param generator DH generator (g)
 * @param gen_len Length of generator
 * @param public_value Public value (g^x mod p)
 * @param pub_len Length of public value
 * @return KeyObject pointer or NULL on error
 */
KeyObject* rn_crypto_key_object_new_dh_public(
    const uint8_t* prime, size_t prime_len,
    const uint8_t* generator, size_t gen_len,
    const uint8_t* public_value, size_t pub_len);

/**
 * Get DH prime from KeyObject.
 * @param key KeyObject pointer
 * @param out Output buffer (can be NULL to get length)
 * @return Length of prime, or -1 if not a DH key
 */
int32_t rn_crypto_key_object_get_dh_prime(KeyObject* key, uint8_t* out);

/**
 * Get DH generator from KeyObject.
 * @param key KeyObject pointer
 * @param out Output buffer (can be NULL to get length)
 * @return Length of generator, or -1 if not a DH key
 */
int32_t rn_crypto_key_object_get_dh_generator(KeyObject* key, uint8_t* out);

/**
 * Check if KeyObject is a DH key.
 * @param key KeyObject pointer
 * @return true if DH key, false otherwise
 */
bool rn_crypto_key_object_is_dh(KeyObject* key);

// ==================== ML-DSA (Post-Quantum Signatures - FIPS 204) ====================

typedef struct MLDSAKeyPair {
    uint8_t* public_key;
    size_t public_key_len;
    uint8_t* secret_key;
    size_t secret_key_len;
} MLDSAKeyPair;

/**
 * Generate ML-DSA key pair.
 * @param level Security level (44, 65, or 87)
 * @return Pointer to MLDSAKeyPair or NULL on error
 */
MLDSAKeyPair* rn_crypto_mldsa_keygen(int32_t level);

/**
 * Sign data with ML-DSA secret key.
 * @param level Security level
 * @param sk Secret key
 * @param sk_len Secret key length
 * @param data Data to sign
 * @param data_len Data length
 * @param out Output buffer for signature
 * @return Signature length, or 0 on error
 */
size_t rn_crypto_mldsa_sign(int32_t level, const uint8_t* sk, size_t sk_len,
                            const uint8_t* data, size_t data_len, uint8_t* out);

/**
 * Verify signature with ML-DSA public key.
 * @param level Security level
 * @param pk Public key
 * @param pk_len Public key length
 * @param data Original data
 * @param data_len Data length
 * @param sig Signature
 * @param sig_len Signature length
 * @return true if valid, false otherwise
 */
bool rn_crypto_mldsa_verify(int32_t level, const uint8_t* pk, size_t pk_len,
                            const uint8_t* data, size_t data_len,
                            const uint8_t* sig, size_t sig_len);

void rn_crypto_mldsa_keypair_free(MLDSAKeyPair* kp);

size_t rn_crypto_mldsa_sig_len(int32_t level);
size_t rn_crypto_mldsa_pk_len(int32_t level);
size_t rn_crypto_mldsa_sk_len(int32_t level);

// ==================== ML-KEM (Post-Quantum Key Encapsulation - FIPS 203) ====================

typedef struct MLKEMKeyPair {
    uint8_t* encapsulation_key;
    size_t encapsulation_key_len;
    uint8_t* decapsulation_key;
    size_t decapsulation_key_len;
} MLKEMKeyPair;

/**
 * ML-KEM one-shot operation: keygen + encapsulate + verify round-trip.
 * @param level Security level (512, 768, or 1024)
 * @param out_ct Output ciphertext buffer
 * @param out_ct_len Output ciphertext length
 * @param out_ss Output shared secret buffer
 * @param out_ss_len Output shared secret length
 * @return 0 on success, negative on error
 */
int32_t rn_crypto_mlkem_oneshot(int32_t level, uint8_t* out_ct, size_t* out_ct_len,
                                uint8_t* out_ss, size_t* out_ss_len);

MLKEMKeyPair* rn_crypto_mlkem_keygen(int32_t level);
int32_t rn_crypto_mlkem_encapsulate(int32_t level, const uint8_t* ek, size_t ek_len,
                                    uint8_t* out_ct, size_t* out_ct_len,
                                    uint8_t* out_ss, size_t* out_ss_len);
int32_t rn_crypto_mlkem_decapsulate(int32_t level, const uint8_t* dk, size_t dk_len,
                                    const uint8_t* ct, size_t ct_len,
                                    uint8_t* out_ss, size_t* out_ss_len);
void rn_crypto_mlkem_keypair_free(MLKEMKeyPair* kp);

size_t rn_crypto_mlkem_ek_len(int32_t level);
size_t rn_crypto_mlkem_dk_len(int32_t level);
size_t rn_crypto_mlkem_ct_len(int32_t level);
size_t rn_crypto_mlkem_ss_len(int32_t level);


#ifdef __cplusplus
}
#endif

#endif // RN_NODE_CRYPTO_H
